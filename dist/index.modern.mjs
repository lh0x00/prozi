import e from"to-fast-properties";import t from"throat";export{default as throat}from"throat";function r(t){return e(t)}class c{static wrap(e){return async function(...t){const r=this;return c.create(async function(c,s){try{c(Promise.resolve(e.apply(r,t)))}catch(e){s(e)}})}}static async immediate(e){return c.create((t,r)=>{Promise.resolve().then(()=>{Promise.resolve("function"==typeof e?e():null).then(t).catch(r)})})}static async timeout(e,t=0){return c.create((r,c)=>{setTimeout(()=>{Promise.resolve("function"==typeof e?e():null).then(r).catch(c)},t)})}static async throat(e,t,r){if(!e||!Array.isArray(e)||!("map"in e))throw new Error("The parameter list received is invalid,it's must be a list or support `map` prototype.");const s=Object.assign({concurrency:this.defaults.concurrency,schedule:!1},r);if(s.concurrency<=0)throw new Error("Quiz throat required concurrency value is greater 0.");return c.map(e,t,s)}static async map(e,r,s){if(!e||!Array.isArray(e)||!("map"in e))throw new Error("The parameter list received is invalid,it's must be a list or support `map` prototype.");const n=Object.assign({concurrency:-1,schedule:!1},s);return c.all(e.map(n.concurrency>0?t(n.concurrency,r):r))}static async from(e){const t=Object.keys(e),c=Object.values(e);return(await this.all(c)).reduce((e,r,c)=>Object.assign(e,{[t[c]]:r}),r())}static async all(...e){const t=e.reduce((e,t)=>e.concat(t),[]);return Promise.all(t)}static defer(e){const t=Object.assign({timeout:-1,cancelable:!0},e),c=r({});return c.state="pending",c.is=r({finalled:()=>"resolved"===c.state||"rejected"===c.state,resolved:()=>"resolved"===c.state,rejected:()=>"rejected"===c.state}),c.promise=new Promise((e,r)=>{if(c.resolve=e,c.reject=r,t.cancelable&&Promise.resolve().then(()=>{c.cancel=c.promise.cancel=function(){const e=new Error("The promise have been canceled.");e.name="PromiseCanceled",c.reject(e)}}),t.timeout>0){let e=setTimeout(()=>{e=-1;const t=new Error("The promise has been timedout.");t.name="PromiseTimedout",c.reject(t)},t.timeout);c.flush=function(){clearTimeout(e),e=-1},c.promise.finally(()=>{c.flush()})}}),c.promise.then(()=>c.state="resolved").catch(()=>c.state="rejected"),c}static run(e,t){const r=c.defer(t);return e().then(r.resolve).catch(r.reject),r.promise}static create(e,t){const r=c.defer(t);return e(r.resolve,r.reject),r.promise}}c.defaults=r({concurrency:4}),c.race=async(...e)=>{const t=e.reduce((e,t)=>e.concat(t),[]);return Promise.race(t)},c.promisify=e=>async(...t)=>new Promise((r,c)=>{e(...t,(e,t)=>{e?c(e):r(t)})}),c.deferify=e=>(...t)=>{const r=c.defer();return r.forward=e(...t,(e,t)=>e?r.reject(e):r.resolve(t)),r};export{c as Quiz,r as fastObjectProperties};
//# sourceMappingURL=index.modern.mjs.map
